# C++核心编程

> 本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。

## 一、内存分区模型

C++程序在执行时，将内存大方向划分为4个区域

- 代码区：存放函数体的二进制代码，由操作系统进行管的；
- 全局区：存放全局变量和静态变量以及常量；
- 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等；
- 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。

**内存四区意义**：

不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程。

#### 1.1 程序运行前

在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域

**代码区**：

- 存放CPU只执行的机器指令
- 代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
- 代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令

**全局区**：

- 全局变量和静态变量存放此处
- 全局区包含了常量区，字符串常量和其他常量也存放在此
- ==该区域的数据在程序结束后由操作系统释放==

**示例**：

``` c++
#include <iostream>
using namespace std;

// 全局变量
int g_a = 10;
int g_b = 10;

// const修饰的全局变量
const int g_c = 9;

int main()
{
    // 全局区

    // 全局变量、静态变量、常量

    // 创建普通局部变量
    int a = 10;
    int b = 10;

    // 静态变量, 在普通变量前加static，属于静态变量
    static int s_a = 10;

    cout << "局部变量a的地址为：" << &a << endl;
    cout << "局部变量b的地址为：" << &b << endl;

    cout << "全局变量a的地址为：" << &g_a << endl;
    cout << "全局变量b的地址为：" << &g_b << endl;

    cout << "静态变量a的地址w为：" << &s_a << endl;

    // 常量
    // 字符串常量
    cout << "字符串常量的地址为：" << &"Hello World" << endl;

    // const修饰的变量
    // 分为：const修饰的全局变量，const修饰的局部变量

    // const修饰的局部变量
    const int d = 9;
    cout << "const修饰全局变量c的地址为：" << &g_c << endl;
    cout << "const修饰局部变量d的地址为：" << &d << endl;

    // system("pause");
    return 0;
}
```

总结：

> 全局区中存储：全局变量、const修饰的全局变量(全局常量)、静态变量、字符串常量。

> 不在全局区存储：局部变量、const修饰的局部变量(局部常量)。

#### 1.2 程序运行后

**栈区**:

- 由编译器自动分配释放，存放函数的参数值，局部变量等
- 注意事项：不要返回局部变量的地址，栈区开辟的数量由编译器自动释放

**示例**：

``` c++
#include <iostream>
using namespace std;

// 栈区数据注意事项：不要返回局部变量的地址
// 栈区的数据由编译器管理和释放

int * func(int b) // 形参也会存储在栈区
{
    b = 100;
    int a = 10; // 局部变量，此变量存放在栈区，而栈区存放的数据在函数运行完自动释放。
    return &a; // 返回局部变量的地址，warning: address of local variable 'a' returned
}

int main()
{
    // 接受func函数的返回值
    int *p = func(20); // 异常
    // 输出
    cout << *p << endl;
    system("pause");
    return 0;
}
```

---

**堆区**

- 由程序员分配释放，若程序员不释放，程序结束时由操作系统回收
- 在C++中主要利用new在堆区开辟空间

**示例**:

``` c++
#include <iostream>
using namespace std;

int * func()
{
    // 利用new关键字，可以将数据开辟到堆区
    // 指针本质也是一个局部变量，放在栈上，指针保存的数据时放在堆区。
    int *p = new int(10);
    cout << &p << endl;
    return p;
}

int main()
{
    // 堆区
    int *p = func();
    cout << *p << " " << p << endl;

    return 0;
}
```

**总结**

> 堆区数据由程序员管理开辟和释放

> 堆区数据利用new关键字进行开辟内存

#### 1.3 new操作符

C++利用==new==操作符在堆区开辟空间

堆区开辟的空间，由程序员手动开辟，手动释放，释放利用操作符==delate==

语法:`new 数据类型`

利用new创建的存放数据的空间，会返回该存放数据空间对应的类型的指针

**示例**:

``` c++
#include <iostream>
using namespace std;

// 1、new的基本语法
int * func()
{
    // 在堆区创建整型的数据
    // 返回该数据类型的指针
    int *p = new int(10); 
    return p;
}

void test01()
{
    int *p = func();
    cout << *p << endl << endl;
    // 堆区的数据由程序员管理开辟和释放
    // 如果需释放需堆区的数据，利用关键字 delete
    delete p;
    // cout << *p << endl; // 乱码
}
// 2、在堆区利用new开辟数组
void test02()
{
    // 创建10个整型数据的数组，在堆区
    int *arr = new int[10]; // 10代表数组有10个元素
    // cout << sizeof(arr) << endl;
    for (int i = 0; i < 10; i++)
    {
        arr[i] = i + 100;
        cout << arr[i] << " ";
    }
    // cout << sizeof(arr) << endl;
    delete[] arr; // 释放数组，需要加[]才可以。
}

int main()
{
    // new操作符
    test01();

    test02();

    return 0;
}
```

## 二、引用

#### 2.1 引用的基本使用

**作用**：给变量起别名

**语法**：`数据类型 &别名 = 原名`

**示例**：

``` c++
#include <iostream>
using namespace std;

int main()
{
    // 引用的基本语法
    int a = 10;
    int &b = a;
    b++;
    cout << a << endl;

    return 0;
}
```

#### 2.2 引用注意事项

- 引用必须初始化
- 引用在初始化后，不可也改变

**示例**：

```c++
#include <iostream>
using namespace std;

int main()
{
    int a = 10;
    // 1、引用必须初始化
    // int &b; // 不可
    int &b = a;
    // 2、引用在初始化后，不可也改变
    int c = 20;
    b = c; // 错误, 这是赋值操作，而不是更改引用
    cout << b << endl;

    return 0;
}
```

#### 2.3 引用做函数参数

**作用**：函数传参时，可以利用引用的技术让形参修饰实参

**优点**：可以简化指针修改实参

**示例**：

```c++
#include <iostream>
using namespace std;

// 1、值传递
void mySwap01(int a, int b)
{
    int temp = a;
    a = b;
    b = temp;
    cout << "mySwap01>>>" << endl;
    cout << "\ta = " << a << endl;
    cout << "\tb = " << b << endl;
}

// 2、地址传递
void mySwap02(int *a, int *b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
    cout << "mySwap02>>>" << endl;
    cout << "\ta = " << *a << endl;
    cout << "\tb = " << *b << endl;
}

// 3、引用传递
void mySwap03(int &a, int &b)
{
    int temp = a;
    a = b;
    b = temp;
    cout << "mySwap03>>>" << endl;
    cout << "\ta = " << a << endl;
    cout << "\tb = " << b << endl;
}



// 打印函数
void printNum(int *a, int *b)
{
    cout << "\n外部>>>" << endl;
    cout << "\ta = " << *a << endl;
    cout << "\tb = " << *b << endl << endl;
}

int main()
{
    int a = 10;
    int b = 20;
    mySwap01(a, b); // 值传递，形参不会修饰实参
    printNum(&a, &b);

    mySwap02(&a, &b); // 地址传递，形参会修饰实参
    printNum(&a, &b);

    mySwap03(a, b); // 引用传递，形参会修饰实参
    printNum(&a, &b);

    return 0;
}
```

> 总结：通过引用参数产生的效果同按地址传递时一样的。引用的语法更清楚简单。

#### 2.4 引用做函数返回值

**作用**：引用是可以作为函数的返回值存在的

**注意**：不要返回局部变量引用

**用法**：函数调用可作为左值

**示例**：

``` c++
#include <iostream>
using namespace std;
// 引用做函数的返回值
// 1、不要返回局部变量的引用
// int& test01()
// {
    //  warning: reference to local variable 'a' returned
    // int a = 10; // 局部变量存放在四区中的`栈区`
    // cout << a << endl;
//     return 100;
// }

// 2、函数的调用可以作为左值
int& test02()
{
    static int a = 10; // 静态变量，存放在全局区
    return a;
}

int main()
{
    // int &ref = test01(); // 异常
    // cout << ref << endl;

    int &ref = test02();
    cout << ref << endl;
    test02() = 100;
    cout << ref << endl;

    return 0;
}
```

#### 2.5 引用的本质

**本质**：引用的本质在c++内部实现是一个指针常量

**讲解示例**：

``` c++
#include <iostream>
using namespace std;

// 发现是引用，转换为 int * const ref = &a;
void func(int &ref)
{
    ref = 100; // ref是引用，转换为 *ref = 100;
}


int main()
{
    int a = 10;
    // 自动转换为 int * const ref = &a; 指针常量是指针指向不可改，也说明为什么引用不可更改
    int &ref = a;
    ref = 20; // 内部发现ref是引用，自动帮我们转换为：*ref = 20;

    cout << "a = " << a << endl;
    cout << "ref = " << ref << endl;

    func(a);
    cout << "a = " << a << endl;
    cout << "ref = " << ref << endl;

    return 0;
}
```

#### 2.6 常量引用

**作用**：常量引用主要用来修饰形参，防止误操作

在函数形参列表中，可以加==const修饰形参==，防止形参改变实参

**示例**：

```c++
#include <iostream>
using namespace std;

// 打印数据
void showValue(const int &val)
{
    // val = 1000; // 异常
    cout << val << endl;
}


int main()
{
    // 常量引用
    // 使用场景：用来修饰形参，防止误操作
    // int a = 10;
    // int &ref = a; // 引用必须引一块合法的内存空间
    // const int &ref02 = 10; // 添加const，编译器将代码改 int temp 10; const int &ref = temp;
    // ref02 = 20; // 加入const之后变为只读，不可修改

    int a = 100;
    showValue(a);
    cout << a << endl;
    return 0;
}
```

## 三、函数提高

#### 3.1 函数默认参数

在C++中，函数的形参列表中形参是可以有默认值的，

语法：`返回值类型 函数名(参数=默认值){}`

**示例**：

``` c++
#include <iostream>
using namespace std;
// 函数的默认参数
// 如果在调用函数没有传参，会寻找默认参数并使用。
int func(int a, int b = 20, int c = 30)
{
    return a + b + c;
}

// 注意事项
// 1、如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须有默认值。
// 2、如果函数声明有默认参数，函数实现就不能有默认参数。
//      - 声明和实现只有一个有默认参数。
int func2(int a, int b = 20);

int main()
{

    cout << func(10) << endl;
    cout << func2(10) << endl;

    return 0;
}

int func2(int a, int b) // int b = 20,错误
{
    return a + b;
}
```

#### 3.2 函数占位参数

C++中函数形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置

**语法**：`返回值类型 函数名(数据类型){}`

在现阶段函数的占位参数存在意义不大，但是后面的课程会用到该技术。

**示例**：

``` c++
#include <iostream>
using namespace std;

// 占位参数
// 返回值类型 函数名(数据类型){}

// 目前阶段的占位参数，我们还用不到，后面课程中会用到
// 占位参数，还可以有默认参数。
void func(int a, int = 10)
{
    cout << a << endl;
}

int main()
{

    func(10);

    return 0;
}
```

#### 3.3 函数重载

###### 3.3.1 函数重载概述

**作用**：函数名可以相同，提高复原性

**函数重载满足条件**：

- 同一个作用域下
- 函数名称相同
- 函数参数类型不同，或者个数不同或者顺序不同

**注意**：函数的返回值不可以作为函数重载的条件

**示例**

```c++
#include <iostream>
using namespace std;

// 函数重载
// 可以让函数的名称相同，提高复用性

// 函数重载的满足条件
// 1、必须在同一个作用域下
// 2、函数名称相同
// 3、函数参数类型不同，或者个数不同，或者顺序不同
void func()
{
    cout << "func 的调用" << endl;
}

void func(int a)
{
    cout << "func 的调用!" << endl;
}

void func(double a)
{
    cout << "func 的调用！！！" << endl;
}

void func(int a, double b)
{
    cout << "a b" << endl;
}

void func(double a, int b)
{
    cout << "b a" << endl;
}

// 注意事项
// 函数的返回值不可以作为函数重载的条件
// int func(double a, int b) // 无法重载仅按返回类型区分的函数
// {
//     cout << "b a" << endl;
// }

int main()
{

    // func();

    // func(10);

    // func(3.14);

    func(10, 3.14);

    func(3.14, 10);

    return 0;
}
```

###### 3.3.2 函数重载注意事项

- 引用作为重载条件
- 函数重载碰到函数默认值

**示例**：

``` c++
#include <iostream>
using namespace std;

// 函数重载的注意事项
// 1、引用作为重载的条件
void func(int &a) // int &a = 10; 不合法
{
    cout << "func() 调用" << endl;
}

void func(const int &a) // const int &a = 10; 合法
{
    cout << "func() 调用!" << endl;
}

// 2、函数重载碰到函数默认参数
void func2(int a, int b=10)
{
    cout << "func2() 调用" << endl;
}

void func2(int a)
{
    cout << "func2() 调用！" << endl;
}


int main()
{
    int a = 10;
    func(a);
    func(10);

    func2(a); // 当函数重载碰到默认参数，出现二义性，报错，尽量避免这种情况。

    return 0;
}
```

## 四、类和对象

C++面向对象的三大特性：==封装、继承、多态==

C++认为==万事万物都皆可对象==，对象上有其属性和行为

**例如**：

​		人可以作为对象，属性有姓名、年龄、升高、体重...，行为有走、跑、跳、吃饭、唱歌...

​		车也可以作为对象，属性有轮胎、方向盘、车灯...，行为有载人、放音乐、放空调...

​		具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类。

#### 4.1 封装

###### 4.1.1 封装的意义

封装是C++面向对象三大特性之一

封装的意义：

- 将属性和行为作为一个整体，表现生活中的事务
- 将属性和行为加以权限控制

**封装意义一**：

​		在设计类的时候，属性和行为写在了一起，表现事务

**语法**：`class 类名{访问权限: 属性/行为};`

**示例1**：设计一个圆类，求圆的周长

``` c++
#include <iostream>
using namespace std;

// 圆周率
const double PI = 3.14;

// 设计一个圆类，求圆的周长
class Round
{
    // 访问权限
    // 公共权限
public:
    // 属性
    int r;
    // 行为    
    // 获取圆的周长
    double per()
    {
        return 2 * PI * r;
    }
};

int main()
{
    // 通过圆类创建具体的圆对象
    // 实例化 （通过一个类，创建一个对象的过程）
    Round round;
    // 对象属性进行赋值操作
    round.r = 10;
    // 调用对象方法 - 求周长
    double result = round.per();
    cout << result << endl;

    return 0;
}
```

**示例2**：设计一个学生类，属性有姓名和学号，可也给姓名和学号赋值，可也显示学生的姓名和学号。

``` c++
#include <iostream>
#include <string>
using namespace std;

class Student 
{
public:
    // 类中的属性和行为，我们统一称为·成员·
    // 属性：成员属性 或 成员变量
    // 行为：成员函数 或 成员方法

    // 属性
    string name; // 姓名
    int id; // 学号
    // 方法
    void showInfo()
    {
        cout << "学生：" << name
             << "\t学号：" << id
             << endl;
    }

    // 给姓名赋值
    void setName(string msg)
    {
        name = msg;
    }

    // 给ID赋值
    void setId(int uid)
    {
        id = uid;
    }

};

int main()
{
    // 对象1
    Student std01;
    std01.name = "珂珂";
    std01.id = 1001;

    // 对象2
    Student std02;
    std02.setName("安安");
    std02.setId(1002);

    // 调用方法
    std01.showInfo();
    std02.showInfo();

    return 0;
}
```

**封装意义二**：

类在设计时，可以把属性和行为放在不同的权限下，加以控制

访问权限有三种：

1. public		公共权限
2. protected  保护权限
3. private      私有权限

**示例**：

```c++
#include <iostream>
#include <string>
using namespace std;

// 访问权限
// 三种
// 公共权限 public          成员- 类内可以访问, 类外可以访问
// 保护权限 protected       成员- 类内可以访问，类外不可以访问, 子类可以访问基类中的内容
// 私有权限 private         成员- 类内可以访问，类外不可也访问，子类不可以访问基类中的内容

class Person
{
public:
    // 公共权限的成员
    string name; // 姓名

protected:
    // 保护权限的成员
    string car; // 汽车

private:
    // 私有权限的成员
    int password; // 密码

public:
    void func()
    {
        name = "珂珂";
        car = "奔驰";
        password = 666666;
    }

    void showInfo()
    {
        cout << name << "\t" << car << "\t" << password << endl;
    }
};

int main()
{
    Person per;
    per.func();

    cout << per.name << endl;
    // cout << per.car << endl; // 类外不可访问
    // cout << per.password << endl; // 类外不可访问

    per.showInfo();

    return 0;
}
```

###### 4.1.2 struct和class区别

在C++中struct和class唯一的区别就在于**默认的访问权限不同**

区别：

- struct 默认权限为公共
- class 默认权限为私有

**示例**：

```c++
#include <iostream>
using namespace std;

// struct 和 class 的区别
// struct 默认权限是公共权限，public
struct C1
{
    int uid; // 默认权限 - 公共
};

// class 默认权限是私有权限，private
class C2
{
    int uid; // 默认权限 - 私有
};

int main()
{
    struct C1 c1;
    c1.uid = 100;
    
    C2 c2;
    // c2.uid = 100; // 异常

    cout << c1.uid << endl;

    return 0;
}
```

###### 4.1.3 成员属性设置为私有

**优点1**：将所有成员设置为私有，可以自己控制读写权限

**优点2**：对于写权限，我们可以检测数据的有效性

**示例**：

``` c++
#include <iostream>
#include <string>
using namespace std;

// 成员属性设置为私有
// 1、可以自己控制读写的权限
// 2、对于写可以检测数据的有效性
class Person
{
public:
    // 设置姓名
    void setName(string name)
    {
        m_Name = name;
    }
    // 获取姓名
    string getName()
    {
        return m_Name;
    }

    // 设置年龄
    void setAge(int age)
    {
        if (age >= 0 && age <= 150)
        {
            m_Age = age;
        }
        else
        {
            cout << "非法参数" << endl;
            m_Age = 0;
        }
    }

    // 获取年龄
    int getAge()
    {
        return m_Age;
    }

    // 设置爱好
    void setLike(string like)
    {
        m_Like = like;
    }

private:
    // 姓名, 可读可写
    string m_Name;
    // 年龄，可读可写, 但范围必须是0 ~ 150
    int m_Age;
    // 爱好，只写
    string m_Like;
};

int main()
{
    Person per;
    per.setName("珂珂");
    cout << per.getName() << endl;
    per.setAge(133);
    cout << per.getAge() << endl;
    per.setLike("编程");

    return 0;
}
```

**练习案例1：设计立方体类**

设计立方体类(Cube)

求出立方体的面积和体积

分别用全局函数和成员函数判断两个立方体是否相等

**示例**:

```c++
#include <iostream>
using namespace std;

class Cube
{
public:
    // 获得单位
    string getUnit()
    {
        unit = "cm";
        return unit;
    }

    // 设置长度
    void setLength(int l)
    {
        length = l;
    }
    int getLength()
    {
        return length;
    }


    // 设置宽度
    void setWidth(int w)
    {
        width = w;
    }
    int getWidth()
    {
        return width;
    }


    // 设置高度
    void setHeight(int h)
    {
        height = h;
    }
    int getHeight()
    {
        return height;
    }

    // 求周长
    int getPerimeter()
    {
        return (2 * (length + width + height));
    }

    // 求体积
    int getVolume()
    {
        return (length * width * height);
    }

    void compared(Cube &temp_c)
    {
        if ((length == temp_c.getLength()) && (width == temp_c.getWidth()) && (height == temp_c.getHeight()))
        {
            cout << "这两个立方体完全相等。" << endl;
        }
        else
        {
            cout << "这两个立方体不相等。" << endl;
        }
    
    }


private:
    int length; // 长度
    int width;  // 宽度
    int height; // 高度
    string unit; // 单位
};


void compared(Cube &c1, Cube &c2)
{
    if ((c1.getLength() == c2.getLength()) && (c1.getWidth() == c2.getWidth()) && (c1.getHeight() == c2.getHeight()))
    {
        cout << "这两个立方体完全相等。" << endl;
    }
    else
    {
        cout << "这两个立方体不相等。" << endl;
    }
}


int main()
{
    Cube c1;
    // 赋值
    c1.setLength(10);
    c1.setWidth(20);
    c1.setHeight(30);
    // 求周长和体积
    int c1_Perimeter = c1.getPerimeter();
    int c1_Volume = c1.getVolume();
    cout << "c1面积:\t" << c1_Perimeter << c1.getUnit() << "**2" << endl;
    cout << "c1体积:\t" << c1_Volume << c1.getUnit() << "**3" << endl;

    Cube c2;
    // 赋值
    c2.setLength(30);
    c2.setWidth(20);
    c2.setHeight(30);
    // 求周长和体积
    int c2_Perimeter = c2.getPerimeter();
    int c2_Volume = c2.getVolume();
    cout << "c2面积:\t" << c2_Perimeter << c2.getUnit() << "**2" << endl;
    cout << "c2体积:\t" << c2_Volume << c2.getUnit() << "**3" << endl;

    // 全局
    compared(c1, c2);
    // 成员
    c1.compared(c2);
    c2.compared(c1);

    return 0;
}
```

**练习案例2：点和圆的关系**

设计一个圆形类(Circle), 和一个点类(Point), 计算点和圆的关系。

**示例**

```c++
/* point.h */
#pragma once
#include <iostream>
using namespace std;

// 点类
class Point
{
public:
	// 读写坐标
	void setPos(int x, int y);
	
	int getX();

	int getY();

private:
	int m_x;
	int m_y;
};
```

```c++
/* point.cpp */
#include "point.h"

// 读写坐标
void Point::setPos(int x, int y)
{
	m_x = x;
	m_y = y;
}
int Point::getX()
{
	return m_x;
}
int Point::getY()
{
	return m_y;
}

```

``` c++
/* circle.h */
#pragma once
#include <iostream>
#include "point.h"
using namespace std;

class Circle
{
public:
	// 读写圆半径
	void setR(int r);
	int getR();

	// 读写圆心
	void setCenter(Point& p);
	Point& getCenter();

	// 比较圆和点的关系
	void compare(Point& p);

private:
	int m_r;
	Point m_center;
};
```

``` c++
/* circle.cpp */
#include <math.h>
#include "circle.h"

void Circle::setR(int r)
{
	m_r = r;
}

int Circle::getR()
{
	return m_r;
}

void Circle::setCenter(Point& p)
{
	m_center = p;
}

Point& Circle::getCenter()
{
	return m_center;
}

void Circle::compare(Point& p)
{
	// 获得相对坐标x和y，即圆的圆心坐标相对点的中心
	int rel_x = m_center.getX() - p.getX();
	int rel_y = m_center.getY() - p.getY();
	// 根据三角函数求斜边
	double h = pow((rel_x * rel_x) + (rel_y * rel_y), 0.5);
	// 和圆半径比较
	if (h > m_r)
	{
		cout << "点在圆外" << endl;
	}
	else if (h == m_r)
	{
		cout << "点在圆上" << endl;
	}
	else
	{
		cout << "点在圆内" << endl;
	}
}
```

```c++
/* 练习案例2：点和圆的关系 */
#include <iostream>
#include "circle.h"
#include "point.h"

int main()
{
	// 创建圆
	Circle c1;
	c1.setR(10);

	// 创建圆心
	Point center;
	center.setPos(10, 10);
	c1.setCenter(center);

	// 创建点
	Point p1;
	p1.setPos(20, 10);

	// 比较其关系
	c1.compare(p1);

	system("pause");
	return 0;
}
```

#### 4.2 对象的初始化和清理

- 生活中我们买的电子产品基本会出场设置，在某一天我们不用时候也会删除一些自己信息数据保证安全。
- C++中的面向对象来源于生活，每个对象也都会有初始设置及其对象销毁的清理数据的设置。

###### 4.2.1 构造函数和析构函数

对象的**初始化和清理**也是两个非常重要的安全问题

- 一个对象或者变量没有初始状态，对其使用后果是未知的。
- 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题。

C++利用了**构造函数**和**析构函数**解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。

对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器会提供编译器提供的构造函数和析构函数是空实现。**

- 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用。
- 析构函数：主要作用于对象**销毁前**系统自动调用，执行一些清理工作。

**构造函数语法**：`类名(){}`

1. 构造函数，没有返回值也不写void
2. 函数名和类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在创建对象时候会自动调用构造，无需手动调用，而且只会调用一次

**析构函数语法**: `~类名(){}`

1. 析构函数，没有返回值也不写void
2. 函数名与类名相同，在名称前符号~
3. 析构函数不可以有参数，因为不可以发生重载
4. 程序在对象销毁前会自动调用析构，无需手动调用，而且只会调用一次

``` c++
#include <iostream>
using namespace std;

// 对象的初始化和清理
// 1、构造函数 进行初始化操作
class Person
{
public:
	// 1.1 构造函数
	// 没有返回值，不写void
	// 函数名 与 类名相同
	// 构造函数有参数，可以发生重载
	// 创建对象时候，构造函数会自动调用
	Person()
	{
		cout << "构造函数的调用." << endl;
	}

	// 2、析构函数 进行清理的操作
	// 没有返回值，不写void
	// 函数名 和 类名相同,但在名称前加 ~
	// 析构函数不可以有参数，所有不可以重载
	// 对象在销毁前，会自动调用析构函数，而且只会调用一次。  
	~Person()
	{
		cout << "析构函数的调用." << endl;
	}
};


// 构造和析构都是必须有的实现，如果我们自己不提供，编译器会提供一个空实现的构造和析构。
void test()
{
	Person p1; // 这里是一个在栈上的数据。
}

int main()
{ha
	test();
	
	//Person p;
    
	system("pause");
	return 0;
}
```

###### 4.2.2 构造函数的分类和调用

两种分类方式：

- 按参数分为：有参构造和无参构造
- 按类型分为：普通构造和拷贝构造

三种调用方式

- 括号法
- 显示法
- 隐式转换法

**示例**：

```c++
#include <iostream>
using namespace std;

// 1、构造函数的分类和调用

// 分类
// 按照参数分类：无参构造(默认构造)、有参构造
// 按照类型分类：普通构造、拷贝构造
class Person
{
public:
	// 构造函数
	Person()
	{
		cout << "Person的无参构造函数调用" << endl;
	}
	Person(int a)
	{
		age = a;
		cout << "Person的有参构造函数调用" << endl;
	}
	// 拷贝构造函数
	Person(const Person& p)
	{
		// 将传入的人身上的所有属性，拷贝到我身上。
		age = p.age;
		cout << "Person的拷贝构造函数调用" << endl;
	}

	// 析构函数
	~Person()
	{
		cout << "Person的析构函数调用" << endl;
	}

	// 展示年龄
	void showAge()
	{
		cout << age << endl;
	}

private:
	int age;

};


// 调用
void test()
{
	// 1、括号法
	//Person p1; // 默认构造函数的调用
	//Person p2(10); // 有参构造函数
	//Person p3(p2); //  拷贝构造函数
	// 注意事项1
	// 调用默认构造函数时候，不要加()
	// 因为下面这行代码，编译器会认为是一个函数的声明，所以不会认为在创建对象
	//Person p4();

	//p2.showAge();
	//p3.showAge();

	// 2、显示法
	//Person p5; // 默认构造函数的调用
	//Person p6 = Person(10); // 有参构造函数
	//Person p7 = Person(p6); // 拷贝构造函数
	// Person(10) -> 匿名对象 特点：当前行执行结束后，系统会立即回收掉匿名对象
	// 注意事项2
	// 不要利用拷贝构造函数进行初始化匿名对象, 编译器会认为Person(p7) === Person p7,即对象的声明
	//Person(p7);

	//p6.showAge();
	//p7.showAge();


	// 隐式转换法
	Person p8 = 10; // 相当于写了一个Person p8 = Person(10); // 有参构造
	Person p9 = p8; // 相当于Person p9 = Person(p8); // 拷贝构造

}

int main()
{
	test();

	system("pause");
	return 0;
}
```

###### 4.2.3 拷贝构造函数调用时机

C++中拷贝构造函数调用时机通常由三种情况

- 使用一个已经创建完毕的对象来初始化一个新对象
- 值传递的方式给函数参数传值
- 以值方式返回局部对象

**示例**:

```c++
#include <iostream>
using namespace std;

class Person
{
public:
	Person()
	{
		cout << "Person默认构造函数调用" << endl;
	}
	Person(int a)
	{
		cout << "Person有参构造函数调用" << endl;
		age = a;
	}
	Person(const Person& p)
	{
		cout << "Person拷贝构造函数调用" << endl;
		age = p.age;
	}

	~Person()
	{
		cout << "Person析构函数调用" << endl;
	}

	// 输出年龄
	void showAge()
	{
		cout << age << endl;
	}

private:
	int age;

};

// 拷贝构造函数调用的时机

// 1、使用一个已经创建完毕的对象来初始化一个新对象
void test01()
{
	Person p1(20);
	Person p2(p1);

	p2.showAge();
}


// 2、值传递的方式给函数参数传值
// Person p -> Person p(p);
void doWork(Person p)
{

}

void test02()
{
	Person p;
	doWork(p);
}


// 3、用值方式返回局部对象
Person doWork02()
{
	Person p1;
	cout << (int*)&p1 << endl;
	return p1;
}


void test03()
{
	Person p = doWork02();
	cout << (int*)&p << endl;
}

int main()
{
	//test01();

	//test02();

	test03();

	system("pause");
	return 0;
}
```

###### 4.2.4 构造函数调用规则

默认情况下，C++编译器至少给一个类添加3个函数

1. 默认构造函数(无参，函数体为空)
2. 默认析构函数(无参，函数体为空)
3. 默认拷贝构造函数，对属性进行值拷贝

构造函数调用规则如下：

- 如果用户定义有参构造函数，C++不在提供默认无参构造，但是会提供默认拷贝构造
- 如果用户定义拷贝构造函数，C++不会提供其他构造函数

**示例**：

```c++
#include <iostream>
using namespace std;
// 构造函数的调用规则

// 1、创建一个类，C++编译器会给每个类添加至少3个函数
// 默认构造	（空实现）
// 析构函数	（空实现）
// 拷贝构造 （值拷贝）

// 2、如果我们写了有参构造函数，编译器就不再提供默认构造，但依然提供默认拷贝构造 

// 3、如果写了拷贝构造函数，编译器就不再提供其他普通构造函数了
class Person
{
public:
	/*Person()
	{
		cout << "Person默认构造调用" << endl;  
	}
	Person(int a)
	{
		cout << "Person有参构造调用" << endl;
		m_Age = a;
	}*/
	Person(const Person& p)
	{
		cout << "Person拷贝构造调用" << endl;
		m_Age = p.m_Age;
	}

	~Person()
	{
		cout << "Person默认析构调用" << endl;
	}
	int m_Age;
};


//void test01()
//{
//	Person p;
//	p.m_Age = 18;
//
//	Person p2(p);
//
//	cout << "P2-Age " << p2.m_Age << endl;
//}
//
//void test02()
//{
//	Person p(28);
//
//	Person p2(p);
//
//	cout << "P2-Age " << p2.m_Age << endl;
//
//}

void test03()
{
	//Person p; 
}


int main()
{
	//test01();

	//test02();

	test03();

	system("pause");
	return 0;
}
```

###### 4.2.5 深拷贝和浅拷贝

深浅拷贝是面试经典问题，也是常见的一个坑

浅拷贝：简单的赋值拷贝操作

深拷贝：在堆区重新申请空间，进行拷贝操作

**示例**：

```c++
#include <iostream>
using namespace std;

// 深拷贝和浅拷贝

class Person
{
public:
	Person()
	{
		cout << "Person默认构造调用" << endl;
	}
	Person(int a, int height)
	{
		m_Age = a;
		m_Height = new int(height);
		cout << "Person有参构造调用" << endl;
	}
	// 自己实现一个拷贝构造函数带来的问题
	Person(const Person& p)
	{
		m_Age = p.m_Age;
		//m_Height = p.m_Height; -> 编译器默认实现的拷贝构造函数
		m_Height = new int(*p.m_Height);
		cout << "Person拷贝构造调用" << endl;
	}

	~Person()
	{
		// 析构代码，将堆区开辟数据做个释放操作
		if (m_Height != NULL)
		{
			// 浅拷贝带来的问题就是浅拷贝堆区内存重复释放
			// 浅拷贝的问题需要利用深拷贝来解决
			delete m_Height;
			m_Height = NULL; // 防止野指针
		}
		cout << "Person默认析构调用" << endl;
	}

	int m_Age;
	int* m_Height; // 身高
};

void test01()
{
	Person p1(18, 160);

	cout << p1.m_Age << " " << *p1.m_Height << endl;

	Person p2(p1);

	cout << p2.m_Age << " " << *(p2.m_Height) << endl;
}

int main()
{

	test01();
	system("pause");
	return 0;
}
```

> 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题。

###### 4.2.6 初始化列表

**作用**：

C++提供了初始化列表语法，用来初始化属性

**语法**：`构造函数():属性1(值1),属性2（(值2)...{} `

**示例**：

```c++
#include <iostream>
using namespace std;

// 初始化列表

class Person
{
public:
	// 传统初始化操作
	/*Person(int a, int b, int c)
	{
		m_A = a;
		m_B = b;
		m_C = c;
	}*/

	// 初始化列表初始属性
	Person(int a, int b, int c) : m_A(a),m_B(b), m_C(c)
	{

	}

	int m_A;
	int m_B;
	int m_C;
};

void test01()
{
	Person p(10, 20, 30);
	//Person p;

	cout << p.m_A << " " << p.m_B << " " << p.m_C << endl;
 
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```

###### 4.2.7 类对象作为类成员

C++类中的成员也也可以是另一个类的对象，我们称该成员为 对象成员

**列如**：

```c++
class A{};
class B
{
  A a;  
};
```

B类中有对象A作为成员，A为对象成员

那么当创建B对象时，A与B的构造和析构顺序时谁先谁后

**示例**：

```c++
#include <iostream>
#include <string>
using namespace std;

// 类对象作为类成员

// 手机类
class Phone
{
public:

	Phone(string p)
	{
		m_PName = p;
		cout << "Phone有参构造函数" << endl;
	}
	~Phone()
	{
		cout << "Phone默认析构函数" << endl;
	}
	// 手机品牌名称
	string m_PName;
};

class Person
{
public:
	// Phone m_Phone = pName 隐式转化法
	Person(string name, string pName): m_Name(name), m_Phone(pName)
	{
		cout << "Person有参构造函数" << endl;
	}
	~Person()
	{
		cout << "Person默认析构函数" << endl;
	}

	// 姓名
	 string m_Name;
	// 手机
	Phone m_Phone;

};

/*
	- 构造顺序？
		- 当其他类对象作为本类成员，构造时候先构造类对象，再构造自身
	- 析构顺序？
		- 析构的顺序和构造相反
*/
void test01()
{
	Person p("珂珂", "OPPO");
	cout << p.m_Name << " " << p.m_Phone.m_PName << endl;
}


int main()
{
	test01();

	system("pause");
	return 0;
}
```

###### 4.2.8 静态成员

静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员

静态成员分为：

- 静态成员变量
  - 所有对象共享同一份数据
  - 在编译阶段分配内存
  - 类内声明，类外初始化
- 静态成员函数
  - 所有对象共享同一个函数
  - 静态成员函数只能访问静态成员变量

**示例1**:静态成员变量

```c++
 #include <iostream>
using namespace std;

// 静态成员变量
class Person
{
public:


	// 1.所有对象都共享同一份数据
	// 2.编译阶段就分配内存
	// 3.类内声明，类外初始化操作
	static int m_A;
	
	int getB()
	{
		return m_B;
	}

	// 静态成员变量也是有访问权限
private:
	static int m_B;
};

int Person::m_A = 100;
int Person::m_B = 200;

void test01()
{
	Person p;
	cout << p.m_A << endl;
	Person p2;
	p2.m_A = 200;
	cout << p.m_A << endl; // 200
}

void test02()
{
	// 静态成员变量，不属于某个对象上，所有对象都共享同一份数据
	// 因此静态成员有两种变量有两种访问方式
	// 1、通过对象进行访问
	Person p;
	cout << p.m_A << endl;
	// 2、通过类名进行访问
	cout << Person::m_A << endl;
}

void test03()
{
	Person p;
	cout << p.getB() << endl;
	//cout << Person::m_B << endl; // 类外访问的不到私有静态成员变量
}

int main()
{
	//test01();

	//test02();

	test03();

	system("pause");
	return 0;
}
```

**示例2**:静态成员函数

```c++
#include <iostream>
using namespace std;

// 静态成员函数
// 所有对象共享同一个函数
// 静态成员函数只能访问静态成员变量

class Person
{
public:
	static void func()
	{
		m_A = 100; // 静态成员函数可也访问 静态成员变量
		//m_B = 200; // 静态成员函数不可以访问 非静态成员变量，无法区分到底是那个对象的m_B
		cout << "static void func 调用" << endl;
	}

	static int m_A;
	int m_B;
	
	// 静态成员函数也是有访问权限的
private:
	static void func2()
	{
		cout << "static void func2 调用" << endl;
	}

};

int Person::m_A = 0;

// 有两种访问方式
void test01()
{
	// 1、通过对象进行访问
	Person p;
	p.func();

	// 2、通过类名进行访问
	Person::func();
	//Person::func2(); // 异常，类外访问不到私有静态成员函数

}


int main()
{
	test01();

	system("pause");
	return 0;
}
```

#### 4.3 C++对象模型和this指针

###### 4.3.1 成员变量和成员函数分开存储

在C++中，类内的成员变量和成员函数分开存储

只有非静态成员变量才属于类的对象上

``` c++
#include <iostream>
using namespace std;

// 成员变量和成员函数是分开存储的

class Person
{
public:

	int m_A; // 非静态成员变量, 属于类的对象上

	static int m_B; // 静态成员变量，不属于类的对象上

	void func() // 非静态成员函数，不属于类的对象上
	{

	}

	static void func02() // 静态成员函数，不属于类的对象上
	{

	}

};

int Person::m_B = 100;

void test01()
{
	Person p;
	// 空对象占用内存空间为：1
	// C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置
	// 每个空对象也应该有一个独一无而的内存地址
	cout << "内存大小: " << sizeof(p) << endl;

}

void test02()
{
	Person p;
	// 4
	cout << sizeof(p) << endl;
}


int main()
{
	//test01();

	test02();

	system("pause");
	return 0;
}
```

###### 4.3.2 this指针概念

通过4.3.1我们知道在C++中成员变量和成员函数是分开存储

每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码

那么问题是：这一块代码是如何区分哪个对象调用自己的呢？

- C++通过特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象**。

this指针是隐含每一个非静态成员函数内的一种指针

this指针不需要定义，直接使用即可

**this指针的用途**：

- 当形参和成员变量同名时，可以this指针来区分
- 在类的非静态成员函数中返回对象本身，可以使用 return *this

```c++
#include <iostream>
using namespace std;

class Person
{
public:
	Person(int age)
	{
		// this指针指向 被调用的成员函数 所属的对象
		this->age = age;
	}

	Person& addAge(Person& p)
	{
		this->age += p.age;
		// this指向p2的指针，而*this指向的就是p2这个对象本体
		return *this;
	}

	int age;

};

// 1、解决名称冲突
void test01()
{
	Person p(18);
	cout << p.age << endl;
}

// 2、返回对象本身用*this

void test02()
{
	Person p1(10);

	Person p2(10);

	// 链式编程思想
	p2.addAge(p1).addAge(p1).addAge(p1);

	cout << p2.age << endl;
}


int main()
{
	//test01();

	test02();

	system("pause");
	return 0;
}
```

###### 4.3.2 空指针访问成员函数

C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针

如果用到this指针，需要加以判断保证代码的健状性

**示例**：

```c++
#include <iostream>
using namespace std;

// 空指针调用成员函数

class Person
{
public:
	void showClassName()
	{
		cout << "this is Person class" << endl;
	}

	void showPersonAge()
	{
		// 报错原因是因为传入指针是为NULL
		// 解决方法
		if (this == NULL)
		{
			return;
		}
		cout << "Age = " << this->m_Age << endl;	
	}

	int m_Age;

};

void test01()
{
	Person* p = NULL;
	
	p->showClassName();	 // 成功
	p->showPersonAge(); // 崩溃
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```

###### 4.3.4 const修饰成员函数

**常函数**：

- 成员函数后加const后我们称为这个函数为**常函数**
- 常函数内不可以修改成员属性
- 成员属性声明时加关键字mutable后，在常函数中依然可以修改

**常对象**：

- 声明对象前加const称该对象为常对象 - 实例化对象时
- 常对象只能调用常函数

**示例**：

```c++
#include <iostream>
using namespace std;


// 常函数
class Person
{
public:
	// this指针本质 是指针常量, 即指针的执行不可修改
	// Person  * const this; -我想指针指向数据不可修改> const Person * const this;
	// 在成员函数后加const， 修饰的是this指针， 让指针指向的值也不可以修改
	void showPerson() const // 相当于 -> const Person * const this;
	{
		 //this->m_A = 100; // 异常，不可修改
		//this = NULL; // this指针不可以修改指针的指向
		this->m_B = 200;
		cout << this->m_B << endl;
	}
	void func()
	{
		m_A = 100;
	}

	int m_A;
	mutable int m_B; // 特殊变量，即使在常函数中，也可以修改这个值,加关注mutable

};

void test01()
{
	Person p1;
	p1.showPerson();
	cout << p1.m_B << endl;
}

// 常对象

void test02()
{
	const Person p; // 在对象前加const，变为常对象
	//p.m_A = 100; // 异常
	p.m_B = 100; // 成功，因m_B是特殊变量，在常对象下也可以修改
	cout << p.m_B << endl;
	// 常对象只能调用常函数
	p.showPerson();
	//p.func(); // 异常，常对象不可以调用普通成员函数，因为普通成员函数可以修改属性
}


int main()
{
	//test01();

	test02();

	system("pause");
	return 0;
}
```

#### 4.4 友元

生活中你的家里有客厅(Public), 有你的卧室(Private)

客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去

但是呢，你也可以允许你的好闺蜜好基友进去。



在程序中，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术



友元的目的就是让一个函数或者类访问另一个类中私有成员



友元的关键字为==friend==

友元的三种实现：

- 全局函数做友元
- 类做友元
- 成员函数做友元

###### 4.4.1 全局函数做友元

```c++
#include <iostream>
#include <string>
using namespace std;

// 建筑物类
class Building
{
	// goodGay全局函数是Building 的好基友，可以访问Building中私有成员
	friend void goodGay(Building& b);
public:
	Building()
	{
		this->sittingRoom = "客厅";
		this->bedRoom = "卧室";
	}


public:

	string sittingRoom; // 客厅

private:
	string bedRoom; // 卧室

};

// 全局函数
void goodGay(Building & b)
{
	cout << "好基友的全局函数 正在访问：" << b.sittingRoom << endl;

	cout << "好基友的全局函数 正在访问：" << b.bedRoom << endl;
}

void test01()
{
	Building building;
	goodGay(building);
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```

###### 4.4.2 类做友元

 ```c++
#include <iostream>
#include <string>
using namespace std;

// 类做友元

class Building;

class GoodGay
{
public:

	GoodGay();
	~GoodGay();
	void visit(); // 参观函数，访问Building中的属性

	Building* building;

};

class Building
{
	// 设置Building友元类GoodGay，表示GoodGay类可以访问此类中的私有成员
	friend class GoodGay;
public:
	Building();

public:
	// 客厅
	string sittingRoom;

private:
	// 卧室
	string bedRoom;

};

// 类外写成员函数
Building::Building()
{
	this->sittingRoom = "客厅";
	this->bedRoom = "卧室";
}

GoodGay::GoodGay()
{
	// 创建建筑物对象
	this->building = new Building;
}

GoodGay::~GoodGay()
{
	delete this->building;
}

void GoodGay::visit()
{
	cout << "好基友类正在访问: " << this->building->sittingRoom << endl;
	cout << "好基友类正在访问: " << this->building->bedRoom << endl;
}

void test01()
{
	GoodGay gg;
	gg.visit();
};


int main()
{
	test01();

	system("pause");
	return 0;
}
 ```

###### 4.4.3 成员函数做友元

```c++
#include <iostream>
#include <string>
using namespace std;

class Building;
class GoodGay
{
public:
	GoodGay();
	~GoodGay();
	// 让visit函数可以访问Building中私有成员
	void visit();
	// 让visit2函数不可以访问Building中私有成员
	void visit2();


public:
	Building* pBuilding;

};

class Building
{
	// 告诉编译器，GoodGay类下的visit成员函数作为本类的好朋友，可以访问私有成员
	friend void GoodGay::visit();
public:
	Building();


public:
	string sittingRoom; // 客厅


private:
	string bedRoom; // 卧室

};

// 类外初始化成员函数
Building::Building()
{
	this->sittingRoom = "客厅";
	this->bedRoom = "卧室";
}

GoodGay::GoodGay()
{
	this->pBuilding = new Building;
}

GoodGay::~GoodGay()
{
	if (this->pBuilding == NULL)
	{
		return;
	}
	delete this->pBuilding;
}

void GoodGay::visit()
{
	cout << "GoodGay->visit正在访问Building的: " << this->pBuilding->sittingRoom << endl;
	cout << "GoodGay->visit正在访问Building的: " << this->pBuilding->bedRoom << endl;
}

void GoodGay::visit2()
{
	cout << "GoodGay->visit2正在访问Building的: " << this->pBuilding->sittingRoom << endl;
	//cout << "GoodGay->visit正在访问Building的: " << this->pBuilding->bedRoom << endl; // 异常
}

void test01()
{
	GoodGay gg;
	gg.visit();
	gg.visit2();
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```

 #### 4.5 运算符重载

运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不用的数据类型

###### 4.5.1 加号运算符重载

**作用**：实现两个自定义数据类型相加的运算

```c++
#include <iostream>
using namespace std;

// 加法运算符重载
class Person
{
public:
	int a;
	int b;

public:
	// 成员函数做加法运算符重载
	Person operator+(Person& p);
	Person operator+(int num);

};

// 1、成员函数做加法运算符重载
Person Person::operator+(Person& p)
{
	Person temp;
	temp.a = this->a + p.a;
	temp.b = this->b + p.b;
	return temp;
}
Person Person::operator+(int num)
{
	Person temp;
	temp.a = this->a + num;
	temp.b = this->b + num;
	return temp;
}

void test01()
{
	Person p1;
	p1.a = 10, p1.b = 10;
	Person p2;
	p2.a = 10, p2.b = 10;
	// p1和p2相加
	// 成员函数重载本质调用：p1.operator+(p2);
	// 全局函数重载本质调用：operator+(p1, p2);
	Person p3 = p1 + p2;
	cout << p3.a << " " << p3.b << endl;
	// 运算符重载也可以发生函数重载、
	Person p4 = p1 + 40;
	cout << p4.a << " " << p4.b << endl;

}

// 2、全局函数做加法运算符重载
//Person operator+(Person& p1, Person& p2)
//{
//	Person temp;
//	temp.a = p1.a + p2.a;
//	temp.b = p1.b + p2.b;
//	return temp;
//}


int main()
{
	test01();

	system("pause");
	return 0;
}
```

> 总结1：对于内置的数据类型的表达式的运算符是不可以进行改变的

> 总结2：不要滥用运算符

###### 4.5.2 左移运算符重载

**作用**：可以输出自定义数据类型

```c++
#include <iostream>
using namespace std;

// 左移运算符重载
class Person
{
	friend ostream& operator<<(ostream& cout, Person& p);
public:
	// 利用成员函数进行重载 左移运算符
	// 通常不会利用成员函数重载<<运算符, 因为无法实现 cout在左侧
	/*void operator<<(cout) -转换> p.operator>>(cout) -简化> p >> cout
	{
	}*/
	Person(int a, int b)
	{
		this->a = a;
		this->b = b;
	}

private:
	int a;
	int b;
};

// 只能利用全局函数重载左移运算符
// ostream对象全局只能有1个
ostream & operator<<(ostream &cout, Person &p) // 本质 operator<<(cout, p); 简化 cout << p;
{
	cout << "Person &p.a: " << p.a << ";\t"
		<< "Person &p.b: " << p.b;
	return cout;
}

void test01()
{
	Person p(10, 10);
	cout << p << endl;

}


int main()
{
	test01();

	system("pause");
	return 0;
}
```

> 总结：重载左移运算符配合友元可以实现输出自定义数据类型

###### 4.5.3 递增运算符重载

**作用**：通过重载递增运算符，实现自己的整数类型

```c++
#include <iostream>
using namespace std;

// 承载递增运算符

// 自定义整型

class MyInteger
{
	friend ostream& operator<<(ostream& cout, const MyInteger& num);
public:
	MyInteger()
	{
		this->m_Int = 0;
	}

	// 重载前置++运算符，返回引用是为了对同一个数据进行操作
	MyInteger& operator++()
	{
		// 先进行++运算
		this->m_Int++;
		// 再将自身进行返回
		return *this;
	}

	// 重载后置++运算符
	// void operator++(int), int代表占位参数，可以用于区分前置和后置递增
	MyInteger operator++(int)
	{
		// 先记录当时数据
		MyInteger temp = *this;
		// 后递增
		this->m_Int++;
		// 返回
		return temp;
	}

private:
	int m_Int;

};

// 左移运算符重载
ostream& operator<<(ostream& cout, const MyInteger& num)
{
	cout << num.m_Int;
	return cout;
}


void test01()
{
	MyInteger num;
	cout << ++num << endl;
	cout << num << endl;

}

void test02()
{
	MyInteger num;
	cout << (num++) << endl;
	cout << num << endl;

}


int main()
{
	//test01();

	test02();

	system("pause");
	return 0;
}
```

###### 4.5.4 赋值运算符重载

C++编译器至少给一个类添加4个函数

1. 默认构造函数(无参，函数体为空)
2. 默认析构函数(无参，函数体为空)
3. 默认拷贝构造函数，对属性进行值拷贝
4. 赋值运算符operator=，对属性进行值拷贝

如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题

**示例**：

```c++
#include <iostream>
using namespace std;

// 赋值运算符重载
class Person
{
public:
	Person(int age)
	{
		this->age = new int(age);

	}
	~Person()
	{
		// 堆区内存重复释放
		if (this->age != NULL)
		{
			delete this->age;
			this->age = NULL;
		}
	}
	
	// 赋值运算符重载
	Person& operator=(Person& p)
	{
		if (this->age != NULL)
		{
			// 应该先判断是否有属性在读取，如果有先释放干净，再进行深拷贝
			delete this->age;
			this->age = NULL;
		}
		// 深度拷贝
		this->age = new int(*(p.age));
		return *this;
	}

	int *age;

};

void test01()
{
	Person p1(18);

	Person p2(20);

	Person p3(30);

	p2 = p1; // 赋值操作

	p3 = p2 = p1;

	cout << "p1.age = " << *(p1.age) << endl;
	
	cout << "p2.age = " << *(p2.age) << endl;

	cout << "p3.age = " << *(p3.age) << endl;


}

int main()
{
	test01();

	/*int a = 10;
	int b = 20;
	int c = 30;
	a = b = c;
	cout << c << " " << b << " " << a << endl;*/

	system("pause");
	return 0;
}
```

###### 4.5.5 关系运算符重载

**作用**：重载关系运算符，可以让两个自定义类型对象进行对比操作

**示例**：

```c++
#include <iostream>
#include <string>
using namespace std;

// 关系运算符重载

class Person
{
public:
	Person(string name, int age)
	{
		this->name = name;
		this->age = age;
	}
	
	// 重载关系运算符
	bool operator==(Person& p)
	{
		if ((this->name == p.name) && (this->age == p.age))
		{
			return true;
		}
		return false;
	}

	bool operator!=(Person& p)
	{
		if ((this->name != p.name) || (this->age != p.age))
		{
			return true;
		}
		return false;
	}


	string name;
	int age;

};

void test01()
{
	Person p1("Tom", 18);
	
	Person p2("Tom", 18);

	if (p1 == p2)
	{
		cout << "p1 == p2 is True." << endl;
	}
	else
	{
		cout << "p1 == p2 is False" << endl;
	}

	if (p1 != p2)
	{
		cout << "p1 != p2 is True" << endl;
	}
	else
	{
		cout << "p1 != p2 is False" << endl;
	}
}


int main()
{
	test01();

	system("pause");
	return 0;
}
```

###### 4.5.6 函数调用运算符重载

- 函数调用运算符()也可以重载
- 由于重载后使用的方式非常像函数的调用，因此称为仿函数
- 仿函数没有固定写法，非常灵活。

**示例**：

```c++
#include <iostream>
#include <string>
using namespace std;

// 函数调用运算符重载

// 打印输出类
class PPrint
{
public:
	// 重载函数调用运算符
	void operator()(string text)
	{
		cout << text << endl;
	}

};

void test01()
{
	PPrint pprint;
	pprint("Hello"); // 由于使用起来非常类似函数调用，因此称为仿函数
}

// 仿函数非常灵活，没有固定的写法
// 加法类
class Add
{
public:
	int operator()(int a, int b)
	{
		return a + b;
	}
};

void test02()
{
	Add add;

	int result = add(10, 100);
	cout << result << endl;

	// 匿名函数对象
	cout << Add()(10, 100) << endl;
}

int main()
{
	//test01();
	test02();
	system("pause");
	return 0;
}
```

#### 4.6 继承

**继承是面向对象三大特性之一**

有些类与类之间存在特殊的关系， 例如下图中：

![Github-ImgLib](https://github.com/isKEKE/ImgLib/blob/main/C++/C++%E7%BB%A7%E6%89%BF.png?raw=true)

我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。

这个时候我们就可以考虑利用继承的技术，减少重复代码

###### 4.6.1 继承的基本语法

例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同
接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看下继承存在的意义以及好处

**普通实现**：

```c++
#include <iostream>
using namespace std;

// 普通实现页面
/*  - 露P写法
// Java页面
class Java
{
public:
	void header()
	{
		cout << "首页、公开课、登录、注册...(公共头部)" << endl;
	}
	void footer()
	{
		cout << "帮助中心、交流合作、站内合作...(公共底部)" << endl;
	}
	void left()
	{
		cout << "Java、Python、C++...(公共分类列表)" << endl;
	}
	void content()
	{
		cout << "Java学科视频" << endl;
	}

};

// Python页面
class Python
{
public:
	void header()
	{
		cout << "首页、公开课、登录、注册...(公共头部)" << endl;
	}
	void footer()
	{
		cout << "帮助中心、交流合作、站内合作...(公共底部)" << endl;
	}
	void left()
	{
		cout << "Java、Python、C++...(公共分类列表)" << endl;
	}
	void content()
	{
		cout << "Python学科视频" << endl;
	}

};

// C++页面...

void test01()
{
	cout << "Java下载视频界面如下: " << endl;
	Java j;
	j.header();
	j.footer();
	j.left();
	j.content();

	cout << "-----------------------" << endl;
	cout << "Python下载视频介界面如下: " << endl;
	Python py;
	py.header();
	py.footer();
	py.left();
	py.content();

}
*/
```

**继承方式**：

```c++
#include <iostream>
using namespace std;
// 继承实现页面
class BasePage
{
public:
	void header()
	{
		cout << "首页、公开课、登录、注册...(公共头部)" << endl;
	}
	void footer()
	{
		cout << "帮助中心、交流合作、站内合作...(公共底部)" << endl;
	}
	void left()
	{
		cout << "Java、Python、C++...(公共分类列表)" << endl;
	}
	void show()
	{
		this->header();
		this->footer();
		this->left();
	}

};


// 继承的好处：减少重复代码
// 语法：class 子类 : 继承方式 父类
// 子类 也成为 派生类
// 父类 也成为 基类


// Java
class Java : public BasePage
{
public:
	void content()
	{
		cout << "Java学科视频" << endl;
	}
	
};

// Python
class Python : public BasePage
{
public:
	void content()
	{
		cout << "Python学科视频" << endl;
	}
};

// C++
class CPP : public BasePage
{
public: 
	void content()
	{
		cout << "C++学科视频" << endl;
	}
};

void test02()
{
	Java j;
	j.show();
	j.content();

	cout << "-----------------------" << endl;

	Python py;
	py.show();
	py.content();

	cout << "-----------------------" << endl;

	CPP cpp;
	cpp.show();
	cpp.content();

}

int main()
{
	//test01();

	test02();

	system("pause");
	return 0;
}
```

**总结**：
继承的好处：==可以减少重复的代码==

class A  : public B
A 类称为子类 或 派生类
B 类称为父类 或 基类

**派生类中的成员，包含两大部分**：
一类是从基类继承过来的，一类是自己增加的成员。
从基类继承过来的表现其共性，而新增的成员体现其个性。

###### 4.6.2 继承方式

继承的语法：`class 子类 : 继承方式 父类`

**继承方式一共有三种：**

- 公共继承
- 保护继承
- 私有继承

![](https://raw.githubusercontent.com/isKEKE/ImgLib/main/C%2B%2B/20200528200613319.jpg)

**示例**：

```c++
#include <iostream>
using namespace std;

// 继承方式

// 1、公共继承
class Base
{
public:
	int a;

protected:
	int b;

private:
	int c;
};

class Son01 : public Base
{
public:
	void func()
	{
		this->a = 10; // 父类公共权限成员 到子类中依然是公共权限
		this->b = 10; // 父类保护权限成员 到子类中依然是保护权限
		//this->c = 10; // 异常，父类中的私有权限成员 子类访问不到
	}
};

void test01()
{
	Son01 s1;
	s1.a = 100;
	//s1.b = 100; // 异常，Son01中依然是保护权限
}

// 保护继承
class Son02 : protected Base
{
public:
	void func()
	{
		this->a = 100; // 父类中公共成员，到子类中变为保护权限
		this->b = 100;	// 父类中保护成员，到子类中变为保护权限
		//this->c = 100; // 异常，子类访问不到父类中的私有成员

	}
};

void test02()
{
	Son02 s2;
	//s2.a = 100; // 在Son02中，a变为保护权限，因此类外不可访问
	//s2.b = 200; // 在Son02也是保护权限
}

// 私有继承
class Son03 : private Base
{
public:
	void func()
	{
		this->a = 100; // 父类中公共成员，到子类变为私有权限
		this->b = 100; // 父类中保护成员，到子类变为私有权限
		//this->c = 100; // 父类私有成员，子类访问不到
	}
};

void test03()
{
	Son03 s3;
	//s3.a = 100; // 到Son03中 变为 私有成员，类外不可访问
}

class GrandSon : public Son03
{
public:
	void func()
	{
		//this->a = 100; // 异常，到了Son03中，a变为私有，即使是再继承的GrandSon，也是不可访问
	}
};

int main()
{

	system("pause");
	return 0;
}
```

###### 4.6.3 继承中的对象模型

**问题**：从父类继承过来的成员，哪些属于子类对象中？

**示例**：

```c++
#include <iostream>
using namespace std;

// 利用开发人员命令提示工具查看对象模型
// 跳转到文件所在路径
// d(数字1) 
// cl /d1 reportSingleClassLayout类名 文件名

// 继承中的对象模型
// 父类继承过来的成员，哪些属于子类对象中？
class Base
{
public:
	int a;
protected:
	int b;
private:
	int c;
};

class Son : public Base
{
public:
	int d;
};

void test01()
{
	Son s; // 16
	// 父类中所有非静态成员属性都会被子类继承下去
	// 父类中私用成员属性，是被编译器给隐藏了，因此是访问不到，但是确实被继承下去了。
	cout << "内存大小s = " << sizeof(s) << endl;
}

int main()
{
	test01();
	system("pause");
	return 0;
}
```

###### 4.6.4 继承中构造和析构的顺序

子类继承父类，当创建子对象，也会调用父类的构造函数

问题：父类和子类的构造和析构顺序是谁先谁后

**示例**：

```c++
#include <iostream>
using namespace std;

// 继承中构造和析构的顺序
class Base
{
public:
	Base()
	{
		cout << "Base的构造函数调用" << endl;
	}
	~Base()
	{
		cout << "Base的析构函数调用" << endl;
	}
};

class Son : public Base
{
public:
	Son()
	{
		cout << "Son的构造函数调用" << endl;
	}
	~Son()
	{
		cout << "Son的析构函数调用" << endl;
	}
};

void test01()
{
	// 继承中的构造和析构顺序如下：
	// 构造函数-> 先调用父类，后调用子类
	// 析构函数-> 先调用子类，后调用父类
	Son s;
}

int main()
{
	test01();
	system("pause");
	return 0;
}
```

> 总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反。

###### 4.6.5 继承同名成员处理方式

问题：当子类与父类出现同名的成员，如果通过子类对象，访问到子类或父类中同名的数据呢？

- 访问子类同名成员，直接访问即可
- 访问父类同名成员，需要加作用域

**示例**：

```c++
#include <iostream>
#include <string>
using namespace std;

// 继承中同名成员处理

class Base
{
public:
	Base()
	{
		this->name = "Base";
	}

	void sayName()
	{
		cout << this->name << endl;
	}
	// 函数重载
	void sayName(int a)
	{
		cout << this->name << " " << a << endl;
	}

	string name;
};

class Son : public Base
{
public:
	Son()
	{
		this->name = "Son";
	}

	void sayName()
	{
		cout << this->name << endl;
	}
	
	string name;
};

void test01()
{
	Son s;
	cout << s.name << endl; // Son
	// 如果通过子类对象，访问到父类中同名成员，需要添加作用域
	cout << s.Base::name << endl; // Base
}

// 同名成员函数处理
void test02()
{
	Son s;
	// 子类
	s.sayName();
	// 父类
	s.Base::sayName();
	// 如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏掉父类中所有同名成员函数
	//s.sayName(10); // 异常
	// 如果想访访问父类中被隐藏的同名成员函数，需要加作用域。
	s.Base::sayName(10);
}

int main()
{
	//test01();

	test02();
	system("pause");
	return 0;
}
```

**总结**：

1. 子类对象可以直接访问到子类中同名成员
2. 子类对象加作用域可以访问到父类同名成员
3. 当子类和父类拥有同名的成员函数，子类会隐藏父类中的同名成员函数，加作用域可以访问到父类中同名函数

###### 4.6.6 继承同名静态成员处理

问题：继承中同名的静态成员在子类对象上如何进行访问？

静态成员和非静态成员出现同名，处理方式一致

- 访问子类同名成员，自己访问即可
- 访问父类同名成员，需要加作用域

**示例**：

```c++
#include <iostream>
using namespace std;

// 继承同名静态成员处理方式
class Base
{
public:
	static int a;
	
	static void func()
	{
		cout << a << endl;
	};
};
// 类外声明
int Base::a = 100;


class Son : public Base
{
public:
	static int a;

	static void func()
	{
		cout << a << endl;
	}
};
int Son::a = 200;

// 同名静态成员属性
void test01()
{
	Son s;
	// 对象访问
	cout << s.a << endl;
	cout << s.Base::a << endl;
	// 类访问
	cout << Son::a << endl;
	// 第一个：：代表通过类名方式访问，第二个：：代表访问父类作用域下
	cout << Son::Base::a << endl;

}

// 同名静态成员函数
void test02()
{
	// 类外访问
	Son::func();
	Son::Base::func();
	// 子类出现和父类同名静态成员函数，也会隐藏父类中所有同名静态成员函数
}


int main()
{
	//test01();

	test02();

	system("pause");
	return 0;
}
```

> 总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问方式（通过对象和通过类名）

###### 4.6.7 多继承语法

C++允许**一个类继承多个类**

语法：`class 子类 : 继承方式 父类1, 继承方式 父类2...`

多继承可能会引发父类中同名成员出现，需要加作用域区分

**C++实际开发中不建议多继承**

**示例**：

```c++
#include <iostream>
using namespace std;

// 多继承语法
class Base1
{
public:
	Base1()
	{
		this->a = 100;
	}
	int a;
};

class Base2
{
public:
	Base2()
	{
		this->a = 200;
	}
	int a;
};

// 子类 需要继承Base1和Base2
// 语法：class 子类 : 继承方式 父类1, 继承方式 父类2...
class Son : public Base1, public Base2
{
public:
	Son()
	{
		this->c = 300;
		this->d = 400;
	}
	int c;
	int d;
};

void test01()
{
	Son s;
	cout << "sizeof(s) = " << sizeof(s) << endl;
	// 当父类中出现同名成员，需要加作用域区分
	//cout << "a = " << s.a << endl; // Son::a不明确, 出现二义性
	cout << "Base1::a = " << s.Base1::a << endl;
	cout << "Base2::a = " << s.Base2::a << endl;
}

int main()
{  
	test01();
	system("pause");
	return 0;
}
```

> 总结：多继承中如果父类中出现了同名情况，子类使用时候需要加作用域。

###### 4.6.8 菱形继承

**菱形继承概念**：

- 两个派生类继承同一个基类
- 又用某个类同时继承这两个派生类
- 这种继承被称为菱形继承，或者钻石继承

**典型的菱形继承案例**：

![](https://github.com/isKEKE/ImgLib/blob/main/C++/%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E6%A1%88%E4%BE%8B%E5%9B%BE.png?raw=true)

**菱形继承问题**：

1. 羊继承了动物的数据，驼同意继承了动物的数据，当草泥马使用数据时，就会产生二义性。
2. 草泥马继承自动物的数据继承了两份，其中我们应该清楚，这份数据我们只需要一份就可以。

```c++
#include <iostream>
using namespace std;

/*
class Alpaca    size(12):
		+---
 0      | +--- (base class Sheep)
 0      | | {vbptr}
		| +---
 4      | +--- (base class Camel)
 4      | | {vbptr}
		| +---
		+---
		+--- (virtual base Animal)
 8      | age
		+---
##################################
vbptr -翻译> 虚基类指针 -指向> vbtable
v -> virtual
b -> base
ptr -> pointer
*/

// 菱形继承
// 动物类
class Animal
{
public:
	int age;
};

// 利用虚继承，可以解决菱形继承的问题
// 继承之前，添加关键字 virtual 变为虚继承
// Animal 类称为 虚基类
// 羊类
class Sheep : virtual public Animal
{

};

// 驼类
class Camel : virtual public Animal
{

};

// 羊驼类
class Alpaca : public Sheep, public Camel
{

};

void test01()
{
	Alpaca alpace;
	alpace.Sheep::age = 18;
	alpace.Camel::age = 20;
	// 当菱形继承，两个父类拥有相同数据，需要加以作用域区分
	cout << "alpace.Sheep::age = " << alpace.Sheep::age << endl;
	cout << "alpace.Camel::age = " << alpace.Camel::age << endl;
	cout << "alpace.age = " << alpace.age << endl;

	// 这份数据我们知道，只要有一份就可以，而菱形继承导致数据有两份，资源浪费
}

int main()
{
	test01();
	system("pause");
	return 0;
}
```

总结：

- 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义
- 利用虚继承可以解决菱形继承问题

#### 4.7 多态

###### 4.7.1 多态的基本概念

**多态是C++面向对象三大特性之一**

多态分两类：

- 静态多态：函数重载和运算符重载属于静态多态，复用函数名
- 动态多态：派生类和虚函数实现运行时多态

静态多态和动态多态区别：

- 静态多态的函数地址早绑定 - 编译阶段确认函数地址
- 动态多态的函数地址晚绑定 - 运行阶段确认函数地址

下面通过案例进行讲解多态

```c++
#include <iostream>
using namespace std;

// 多态

// 动态多态满足条件
// 1. 都有继承关系
// 2. 子类要重新父类的虚函数

// 动态多态使用
// - 父类的指针或引用 指向子类对象

// 动物类
class Animal
{
public:
	// 虚函数
	virtual void speak()
	{
		cout << "动物在说话" << endl;
	}
};

// 猫类
class Cat : public Animal
{
public:
	// 重写 - 函数返回值类型，函数名参数列表完全相同
	void speak()
	{
		cout << "小猫在说话" << endl;
	}
};

// 狗类
class Dog : public Animal
{
public:
	void speak()
	{
		cout << "小狗在说话" << endl;
	}
};

// 执行说话的函数
// 属于地址早绑定，在编译阶段就确认函数地址
// 如果想执行猫说话，那么这个函数地址就不能提前绑定，需要在运行阶段进行绑定，地址晚绑定
void doSpeak(Animal& animal) // Animal & animal = cat;
{
	animal.speak();
}

void test01()
{
	Cat cat;
	doSpeak(cat);

	Dog dog;
	doSpeak(dog);
}


int main()
{
	test01();

	system("pause");
	return 0;
}
```

**总结**：

多态满足条件：

- 有继承关系
- 子类重写父类中的虚函数

多态使用条件

- 父类指针或引用指向子类对象

重写：函数返回值类型 函数名 参数列表 完全一致称为重写

**多态原理刨析图**:

![](https://github.com/isKEKE/ImgLib/blob/main/C++/%E5%A4%9A%E6%80%81%E8%99%9A%E5%87%BD%E6%95%B0.png?raw=true)

###### 4.7.2 多态案例一 计算机类

案例描述：

分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类

多态的优点：

- 代码组织结构清晰
- 可读性强
- 利于前期和后期的扩展以及维护

```c++
#include <iostream>
#include <string>
using namespace std;

// 普通写法
class Calculator
{
public:
	int calculation(char character)
	{
		if (character == '+')
		{
			// 加法
			return this->num01 + this->num02;
		}
		else if (character == '-')
		{
			// 减法
			return this->num01 - this->num02;
		}
		else if (character == '*')
		{
			// 乘法
			return this->num01 * this->num02;
		}
		// 如果扩展新的功能，需要修改源码
		// 在真实开发中 提倡 开闭原则
		// 开闭原则：对扩展进行开放，对修改进行关闭
	}

	int num01;
	int num02;
};

void test01()
{
	string reply;
	Calculator calc;
	char character;
	while (true)
	{
		cout << ">>>";
		cin >> reply;
		if (reply == "q")
		{
			break;
		}
		else if (reply == "calc")
		{
			cout << "计算器操作：" << endl;
			cin >> calc.num01 >> character >> calc.num02;
			cout << "result = " << calc.calculation(character) << endl;

		}
	}
}

// 利用多态实现计算器
// 多态好处：
// 1.组织结构清晰
// 2.可读性强
// 3.对于前期和后期扩展以及维护性高
// 
// 实现计算器抽象类
class AbstractCalculator
{
public:
	virtual int calculation()
	{
		return 0;
	}
	int number01;
	int number02;
};

// 加法计算器类
class AddCalculator : public AbstractCalculator
{
public:
	int calculation()
	{
		return number01 + number02;
	}
};

// 减法计算器类
class SubCalculator : public AbstractCalculator
{
public:
	int calculation()
	{
		return number01 - number02;
	}
};

// 乘法计算器类
class MulCalculator : public AbstractCalculator
{
public:
	int calculation()
	{
		return number01 * number02;
	}
};

void test02()
{
	// 多态使用条件
	// 父类指针或引用指向子类对象

	// 加法计算器
	/*
	AbstractCalculator* a_calc_p = new AddCalculator;
	a_calc_p->number01 = 10;
	a_calc_p->number02 = 10;
	cout << a_calc_p->calculation() << endl;
	// 释放
	delete a_calc_p;
	*/
	
	string reply;
	AbstractCalculator* a_calc_p; // 父类指针

	int number01;
	int number02;
	char character;

	while (true)
	{
		cout << ">>>";
		cin >> reply;
		if (reply == "q")
		{
			break;
		}
		else if (reply == "calc")
		{
			cout << "计算器：" << endl;
			cin >> number01 >> character >> number02;
			if (character == '+')
			{
				// 加法
				a_calc_p = new AddCalculator;
			}
			else if (character == '-')
			{
				// 减法
				a_calc_p = new SubCalculator;
			}
			else if (character == '*')
			{
				// 乘法
				a_calc_p = new MulCalculator;
				
			}
			else
			{
				a_calc_p = NULL;
			}
			// 运算
			if (a_calc_p != NULL)
			{
				a_calc_p->number01 = number01;
				a_calc_p->number02 = number02;
				cout << "result = " << a_calc_p->calculation() << endl;
				// 释放
				delete a_calc_p;
				a_calc_p = NULL;

			}
		}
	}

}

int main()
{
	//test01();

	test02();

	system("pause");
	return 0;
}
```

> 总结：C++开发提倡利用多态设计程序架构，因为多态优点很多

###### 4.7.3 纯虚函数和抽象类

在多态中，通常父类中虚函数的实现是毫无意义，主要都是调用子类重写的内容

因此可以将虚函数改为**纯虚函数**

纯虚函数语法：`virtual 返回值类型 函数名 (参数列表) = 0;`

当类中有了纯虚函数，这个类也称为==抽象类==

**抽象类特点**：

- 无法实例化对象
- 子类必须重写抽象类中的纯虚函数，否则也属于抽象类

**示例**：

```c++
#include <iostream>
using namespace std;

// 纯虚函数和抽象类
class Base
{
public:
	// 纯虚函数，这类只要有一个纯虚函数，这个类称为抽象类
	// 抽象类特性：
	// 1. 无法实现实例化对象
	// 2. 抽象类的子类，必须要重写父类中的纯虚函数，否则也属于抽象类
	virtual void func() = 0;
};

class Child : public Base
{
public:
	virtual void func()
	{
		cout << "Child::func()" << endl;
	}
};

void test01()
{
	// 抽象类无法实例化
	//Base base; // 异常
	//new Base; // 异常

	//Child child; // 异常
	Child child; // Child::func(){}, 子类必须重写父类中的纯虚函数，否则无法实例化对象
	child.func();
}


int main()
{
	test01();
	system("pause");
	return 0;
}
```

###### 4.7.4 多态案例二-制作茶饮

**案例描述**：

制作饮品的大致流程：煮水 - 冲泡 - 倒入杯中 - 加入辅料

利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶

![制作茶饮.png](https://github.com/isKEKE/ImgLib/blob/main/C++/%E5%88%B6%E4%BD%9C%E8%8C%B6%E9%A5%AE.png?raw=true)

```c++
#include <iostream>
#include <string>
using namespace std;

// 基类 - 饮品
class AbstractDrink
{
public:
	// 煮水
	virtual void boilWater() = 0;
	// 冲泡
	virtual void brew() = 0;
	// 倒入杯中
	virtual void pour() = 0;
	// 加入辅料
	virtual void addAccessories() = 0;
	
	// 制作饮品
	void makeDrink()
	{
		this->boilWater();
		this->brew();
		this->pour();
		this->addAccessories();
	}

	// 名称
	string name;
};

// 派生类 - 咖啡
class Coffee : public AbstractDrink
{
public:
	Coffee()
	{
		this->name = "咖啡";
	}

	// 煮水
	virtual void boilWater()
	{
		cout << "煮水" << endl;
	}

	// 冲泡
	virtual void brew()
	{
		cout << "冲泡" << this->name << endl;
	}

	// 倒入杯中
	virtual void pour()
	{
		cout << "倒入杯中" << endl;
	}
	// 加入辅料
	virtual void addAccessories()
	{
		cout << "加入糖和牛奶" << endl;
	}
};

// 派生类 - 茶
class Tea : public AbstractDrink
{
public:
	Tea()
	{
		this->name = "茶叶";
	}

	// 煮水
	virtual void boilWater()
	{
		cout << "煮水" << endl;
	}

	// 冲泡
	virtual void brew()
	{
		cout << "冲泡" << this->name << endl;
	}

	// 倒入杯中
	virtual void pour()
	{
		cout << "倒入杯中" << endl;
	}
	// 加入辅料
	virtual void addAccessories()
	{
		cout << "加入柠檬" << endl;
	}
};

// 制作饮品
void doWork(AbstractDrink* a_drink_p)
{
	a_drink_p->makeDrink();
	delete a_drink_p;
}


void test01()
{
	cout << "制作咖啡: " << endl;
	doWork(new Coffee);

	cout << endl;

	cout << "制作茶叶：" << endl;
	doWork(new Tea);
}

int main()
{
	test01();
	system("pause");
	return 0;
}
```

###### 4.7.5 虚析构和纯虚析构

多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码

解决方式：将父类中析构改为虚析构或者纯虚析构

虚析构和纯虚析构共性;

- 可以解决父类指针释放子类对象
- 都需要有具体的函数实现

虚析构和纯虚析构区别：

- 如果纯虚析构，该类属于抽象类，无法实例化对象

虚析构语法：
`virtual ~类名(){}`
纯虚析构语法：
`virtual ~类名() = 0;`
`类名::~类名(){}`

**示例**：

```c++
#include <iostream>
#include <string>
using namespace std;

// 虚析构和纯虚析构
class Animal
{
public:
	Animal()
	{
		cout << "Animal构造函数调用" << endl;
	}
	// 利用虚析构可以解决 父类指针释放子类对象时不干净的问题
	/*virtual ~Animal()
	{
		cout << "Animal虚析构函数抵用" << endl;
	}*/

	// 纯虚析构
	// 有了纯虚析构之后，这个类也属于抽象类，无法实例化对象
	virtual ~Animal() = 0;

	// 纯虚函数
	virtual void speak() = 0;

};
// 类外实现纯虚析构 - 必须
// 因为父类也有属性可能在堆区开辟
Animal::~Animal()
{
	cout << "Animal纯虚析构函数调用" << endl;
}


class Cat : public Animal
{
public:
	Cat(string name)
	{
		cout << "Cat构造函数调用" << endl;
		this->name = new string(name);
	}

	~Cat()
	{
		cout << "Cat析构函数调用" << endl;
		if (this->name != NULL)
		{
			delete this->name;
			this->name = NULL;
		}
	}

	virtual void speak()
	{
		cout << *(this->name) << "小猫在说话" << endl;
	}
	string* name;
};

void test01()
{
	Animal* animal = new Cat("汤姆");
	animal->speak();
	// 父类指针在析构时，不会调用子类中析构函数，导致子类如果有堆区的属性，出现内存泄露。
	delete animal;
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```

**总结**：

1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象
2. 如果子类中没有堆区数据，可以不写虚析构或纯虚析构
3. 拥有纯虚析构的类也属于抽象类

###### 4.7.6 多态案例三-电脑组装

**案例描述**：

电脑主要组成部件为CPU（用于计算），显卡(用于显示)，内存条（ 用于存储）

将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenove厂商

创建电脑类提供电脑工作的函数，并且调用每个零件工作的接口

测试时组装三台不同的电脑进行工作w

**示例**：

```c++
#include <iostream>
#include <string>
using namespace std;


// CPU - 基类
class AbstractCPU
{
public:
	// 计算
	virtual void calc() = 0;
};

// 显卡 - 基类
class AbstractGPU
{
public:
	// 显示
	virtual void showed() = 0;
};

// 内存条 - 基类
class AbstractRAM
{
public:
	// 存储
	virtual void saved() = 0;
};


// Lenove
class LenoveCPU : public AbstractCPU
{
public:
	void calc()
	{
		cout << "LenoveCPU开始 - 计算" << endl;
	}
};

class LenoveGPU : public AbstractGPU
{
public:
	void showed()
	{
		cout << "LenoveGPU开始 - 显示" << endl;
	}
};

class LenoveRAM : public AbstractRAM
{
public:
	void saved()
	{
		cout << "LenoveRAM开始 - 存储" << endl;
	}
};

// Intel
class IntelCPU : public AbstractCPU
{
public:
	void calc()
	{
		cout << "IntelCPU开始 - 计算" << endl;
	}
};

class IntelGPU : public AbstractGPU
{
public:
	void showed()
	{
		cout << "IntelGPU开始 - 显示" << endl;
	}
};

class IntelRAM : public AbstractRAM
{
public:
	void saved()
	{
		cout << "IntelRAM开始 - 存储" << endl;
	}
};


// 计算机类
class Computer
{
public:
	Computer(AbstractCPU* cpu, AbstractGPU* gpu, AbstractRAM* ram)
	{
		this->cpu = cpu;
		this->gpu = gpu;
		this->ram = ram;
	}

	~Computer()
	{
		if (this->cpu != NULL)
		{
			delete this->cpu;
			this->cpu = NULL;
		}
		if (this->gpu != NULL)
		{
			delete this->gpu;
			this->gpu = NULL;
		}
		if (this->ram != NULL)
		{
			delete this->ram;
			this->ram = NULL;
		}
	}

	// 工作
	void worked()
	{
		this->cpu->calc();
		this->gpu->showed();
		this->ram->saved();
	}

private:
	// CPU
	AbstractCPU* cpu;
	// GPU
	AbstractGPU* gpu;
	// RAM
	AbstractRAM* ram;
};


void test01()
{
	// 第一台
	IntelCPU* i_cpu = new IntelCPU;
	IntelGPU* i_gpu = new IntelGPU;
	IntelRAM* i_ram = new IntelRAM;
	Computer* computer1 = new Computer(i_cpu, i_gpu, i_ram);
	computer1->worked();
	// 内存释放
	delete computer1;

	cout << endl;

	// 第二台
	Computer* computer2 = new Computer(new LenoveCPU, new LenoveGPU, new LenoveRAM);
	computer2->worked();
	// 内存释放
	delete computer2;

	cout << endl;

	// 第三台
	Computer* computer3 = new Computer(new IntelCPU, new IntelGPU, new LenoveRAM);
	computer3->worked();
	// 内存释放
	delete computer3;
}	

int main()
{
	test01();
	system("pause");
	return 0;
}
```

## 五、文件操作

程序运行时产生的数据都属于临时数据，程序一旦运行运行结束都会释放

通过**文件可以将数据持久化**

C++中对文件的操作需要包含头文件==\<fstream\>==

文件类分两种：

1. **文本文件**：文件以文本的ASCII码形式存储存储在计算机中
2. **二进制文件**：文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们

操作文件的三大类：

1. ofstream: 写操作
2. ifstream：读操作
3. fstream：读写操作

#### 5.1 文本文件

###### 5.1.1 写文件

```c++
// 1.包含头文件
#include <fstream>
using namespace std;

int main()
{
	// 2.创建流对象
	ofstream ofs; // 写文件
	// 3.打开文件
	// ofs.open("文件路径",打开方式)
	ofs.open("C:\\Users\\86131\\Desktop\\Hello.txt", ios::out);
	// 4.写数据
	ofs << "写入的数据" << endl;
	// 5.关闭文件
	ofs.close();
	system("pause");
	return 0;
}
```

文件打开方式：

| 打开方式    | 解释                       |
| ----------- | -------------------------- |
| ios::in     | 为读文件而打开文件         |
| ios::out    | 为写文件而打开文件         |
| ios::ate    | 初始位置；文件尾           |
| ios::app    | 追加方式写文件             |
| ios::trunc  | 如果文件存在先删除，再创建 |
| ios::binary | 二进制方式                 |

**注意**：文件打开方式可以配合使用，利用|操作符

**例如**：用二进制方式写文件`ios::binary | ios::out`

**示例**：

```c++
// 1.包含头文件
#include <iostream>
#include <fstream>
using namespace std;

// 文本文件 写文件

void test01()
{
	// 创建流对象
	ofstream ofs;
	// 打开文件
	ofs.open(".//text.txt", ios::out);
	// 写数据
	ofs << "Hello";
	// 关闭文件
	ofs.close();
}

int main()
{
	test01();
	system("pause");
	return 0;
}
```

总结：

- 文件操作必须包含头文件fstream
- 写文件可以利用ofstream，fstream类
- 打开文件时候需要指定操作文件的路径，以及打开方式
- 利用<<可以向文件中写数据
- 操作完毕，要关闭文件

###### 5.1.2 读文件

读文件与写文件步骤相似，但读取方式相对较多

多文件步骤如下：

1. 包含头文件

   `#include <fstream>`

2. 创建流对象

   `ifstream ifs;`

3. 打开文件并判断文件是否打开成功

   `ifs.open("文件路径", 打开方式);`

4. 读数据

   四种方式读取

5. 关闭文件

**示例**：

```c++
#include <iostream>
#include <fstream>
#include <string>
using namespace std;

void test01()
{
	// 创建流对象
	ifstream ifs;
	// 打开文件,并判断是否打开成功
	ifs.open("C:\\Users\\86131\\Desktop\\VIP电影.txt", ios::in);
	if (!ifs.is_open())
	{
		cout << "文件打开失败" << endl;
		return;
	}
	// 文件读取
	// 第一种
	/*char buf[1024] = { 0 };
	while (ifs >> buf)
	{
		cout << buf << endl;
	}*/

	// 第二种
	/*char buf[1024] = { 0 };
	while (ifs.getline(buf, sizeof(buf)))
	{
		cout << buf << endl;
	}*/

	// 第三种
	/*string buf;
	while (getline(ifs, buf))
	{
		cout << buf << endl;
	}*/

	// 第四种
	char c;
	while ((c = ifs.get()) != EOF) // EOF -> end of file
	{
		cout << c;
	}

	// 关闭文件
	ifs.close();
}


int main()
{
	test01();
	system("pause");
	return 0;
}
```

**总结**：

- 读文件可以利用ifstream，或者fstream类
- 利用is_open函数可以判断文件是否打开成功
- close关闭文件

#### 5.2 二进制文件

以二进制的方式对文件进行读写操作

打开方式要指定为==ios::binary==

###### 5.2.1 写文件

二进制方式写文件主要利用流对象调用成员函数write

函数原型：`ofstream& write(const char * buffer, int len);`

参数解释：字节指针buffer指向内存中一段存储空间。len是读写的字节数。

**示例**：

```c++
#include <fstream>
using namespace std;

// 二进制文件 写文件
class Person
{
public:
	char name[64]; // 姓名
	int age; // 年龄
};

void test01()
{
	// 创建流对象
	ofstream ofs("C:\\Users\\86131\\Desktop\\test.txt", ios::out | ios::binary);
	// 打开文件
	//ofs.open("C:\\Users\\86131\\Desktop\\test.txt", ios::out | ios::binary);
	// 写数据
	// 结构体初始化
	Person p = {"张三", 18};
	// (const char*) 强转
	ofs.write((const char*)&p, sizeof(p));
	//关闭文件
	ofs.close();
}

int main()
{
	test01();
	system("pause");
	return 0;
}
```

**总结**：

- 文件输出流对象可以通过write函数，以二进制方式写数据

###### 5.2.2 读文件

二进制方式读文件主要利用流对象调用成员函数read

函数原型：`ifstream& read(read *buffer, int len)`

参数解释：字节指针buffer指向内存中一段存储空间，len是读写的字节数

示例：

```c++
#include <iostream>
#include <fstream>
using namespace std;
const char filepath[128] = "C:\\Users\\86131\\Desktop\\test.txt";

class Person
{
public:
	char name[64];
	int age;
};

void test01()
{
	// 创建流对象
	ifstream ifs;
	// 打开文件 - 二进制模式
	ifs.open(filepath, ios::in | ios::binary);
	// 判断文件是否打开
	if (!ifs.is_open())
	{
		cout << "文件打开失败" << endl;
		return;
	}
	// 读取文件
	Person p;
	ifs.read((char*)&p, sizeof(p));
	// 关闭文件
	ifs.close();

	// 打印
	cout << "p.name = " << p.name << endl;
	cout << "p.age = " << p.age << endl;

}

int main()
{
	test01();
	system("pause");
	return 0;
}
```

- 文件输入流对象，可以通过read函数，以而记者方式读数据
